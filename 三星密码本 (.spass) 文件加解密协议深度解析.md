### 三星密码本 (.spass) 文件加解密协议深度解析

本文档基于对三星密码本 (`.spass`) 文件格式的逆向工程分析，特别是对 **0xdeb7ef** 的开源项目 **spass-manager** 的研究成果，旨在对该文件的内部数据结构、加密流程与解密步骤，以及其所采用的密码学技术栈进行一次全面、深入的阐述。

#### `.spass` 文件概述

三星密码本 (`Samsung Pass`) 是一款内置于三星设备中的密码管理工具，允许用户存储网站登录凭证、银行卡信息和地址等敏感数据。为了方便用户在不同设备间迁移数据，三星密码本提供了导出功能，生成一个以 `.spass` 为后缀的加密备份文件。此文件采用了一套强大且符合行业标准的多层安全机制，确保了其中存储的敏感信息即使在文件泄露的情况下也难以被破解。

---

### 第一部分：核心数据结构与预处理

在执行任何加密操作之前，应用程序首先需要将内部管理的多元化数据统一为一种标准化的、可供加密处理的格式。此过程涉及数据结构化与编码两个关键步骤。

#### 1. 内部数据结构化：类CSV格式

所有待导出的凭证信息，包括登录凭证、银行卡、地址等，被统一组织成一种类似于CSV（逗号分隔值）的文本格式。其核心特点如下：

*   **字段分隔符**：与标准CSV使用逗号不同，`.spass` 内部格式采用分号 (`;`) 作为各个字段（如用户名、密码、网址、创建日期等）之间的分隔符。
*   **数据类型分隔**：不同的数据类别（例如，密码凭证、地址信息）之间，使用一个特殊的关键字 `next_table` 作为明确的边界分隔符。这使得在解析时能够准确地区分不同类型的数据集合。

#### 2. 双重Base64编码：确保数据完整性

为了保证数据在加密和传输过程中的完整性，并防止特殊字符干扰后续处理流程，三星采用了一种严谨的“双重Base64编码”策略。

1.  **第一层编码（字段级）**：
    *   将每一个独立的字段（例如，一个用户名、一个密码或一个网址）分别进行一次独立的Base64编码。这一步确保了每个数据单元都被转换成安全的ASCII字符集。

2.  **数据拼接**：
    *   将经过第一层编码后的各个字段，使用分号 (`;`) 连接起来，形成代表单条完整记录（如一个网站的所有登录信息）的字符串。

3.  **第二层编码（文件级）**：
    *   所有拼接好的记录和 `next_table` 分隔符共同组成一个巨大的文本块。在后续加密流程的最后一步，整个加密后的二进制数据块（包含盐、IV和密文）会再进行一次整体的Base64编码，最终生成 `.spass` 文件的可见内容。

这个经过结构化和编码处理的大文本块，构成了等待加密的“核心明文数据”。

---

### 第二部分：加密流程详解

加密是将预处理后的核心数据转化为安全的 `.spass` 文件的核心环节。该流程遵循了业界公认的最佳密码学实践，通过随机化、密钥派生和强对称加密算法，构建起坚固的安全防线。

#### 1. 生成加密参数：盐 (Salt) 与初始化向量 (IV)

为确保每次加密的输出都是唯一的，从而杜绝“相同密码、相同文件”的现象，程序会首先生成两个至关重要的随机参数：

*   **生成随机盐 (Salt)**：程序会通过加密安全的伪随机数生成器（CSPRNG）创建一个 **20字节** 的随机盐。盐的核心作用是与用户的主密码结合，用于后续的密钥派生。这使得即使多个用户使用相同的主密码，他们派生出的加密密钥也完全不同，从而有效抵御彩虹表 (Rainbow Table) 和字典攻击。
*   **生成随机初始化向量 (IV)**：紧接着，程序会生成一个 **16字节** 的随机IV。在AES的CBC（密码块链接）模式下，IV用于随机化第一个明文块的加密过程。其存在确保了即使是完全相同的明文数据，在每次加密时（只要IV不同）生成的密文也各不相同，极大地增强了加密的语义安全性。

#### 2. 派生加密密钥：从主密码到强密钥

直接使用用户输入的主密码进行加密是极不安全的做法。为此，三星采用了强大的 **PBKDF2 (Password-Based Key Derivation Function 2)** 算法来派生一个高强度的加密密钥。

*   **核心算法**: PBKDF2
*   **伪随机函数 (PRF)**: **HMAC-SHA-256**。这指定了PBKDF2内部迭代时使用的哈希函数为安全的SHA-256。
*   **迭代次数**: **70,000次**。这是一个关键的安全参数。通过执行7万次哈希迭代，极大地增加了计算成本。这种被称为“密钥拉伸”(Key Stretching) 的技术，使得攻击者即使获取了文件和盐，也需要耗费巨大的计算资源才能尝试破解一个猜测的密码，有效延缓了暴力破解的速度。
*   **输入**:
    *   用户设置的主密码。
    *   第一步生成的20字节随机盐。
*   **输出**: 一个 **32字节 (256位)** 的派生密钥。此密钥具备足够的熵，强度远高于原始的用户密码，将被用于核心数据的对称加密。

#### 3. 核心数据加密：AES-256-CBC

使用上一步派生出的高强度密钥，对经过预处理的“核心数据”文本块进行对称加密。

*   **加密算法**: **AES-256-CBC**。
    *   **AES (高级加密标准)**：目前最流行和安全的块加密算法之一，块大小为128位（16字节）。
    *   **256位密钥**: 使用32字节的密钥长度，提供了极高的安全级别。
    *   **CBC (密码块链接模式)**：一种工作模式，通过将前一个密文块与下一个明文块进行异或操作，实现了加密块之间的关联，隐藏了明文数据的模式。
*   **密钥**: 第二步中由PBKDF2生成的32字节派生密钥。
*   **初始化向量 (IV)**: 第一步生成的16字节随机IV。
*   **填充 (Padding)**: AES作为块加密算法，要求待加密的数据长度必须是块大小（16字节）的整数倍。因此，在加密前，程序会自动在数据末尾添加符合 **PKCS#7** 标准的填充。PKCS#7填充规则能确保数据被正确地补齐至块边界，并且在解密后可以被无歧义地识别并安全移除。

#### 4. 文件组装与最终编码

加密完成后，将各个独立的二进制组件按照精确的顺序拼接起来，形成最终的文件内容。

*   **拼接顺序**: `[20字节盐] + [16字节IV] + [AES加密后的核心数据密文]`
    *   将盐和IV明文存储在文件头部是一种标准做法。它们不属于秘密，其作用在于为解密过程提供必要的、公开的参数。
*   **最终Base64编码**: 将这个拼接而成的完整二进制数据流进行一次整体的Base64编码，生成最终的、由ASCII字符组成的 `.spass` 文件内容。这就是用户在文本编辑器中打开文件时看到的字符串。

---

### 第三部分：解密流程详解

解密是加密的逆向过程，其目标是从 `.spass` 文件和用户主密码中，安全、准确地还原出原始的凭证信息。

**1. 读取、清理与解码**
*   **读取文件**: 首先，程序读取 `.spass` 文件的全部内容。
*   **清理空白字符**: `.spass` 文件末尾可能包含不可见的空白字符（如换行符），这些字符会干扰严格的Base64解码。因此，必须先清理掉文件内容末尾的所有空白字符。
*   **Base64解码**: 对清理后的内容执行Base64解码，将其从ASCII字符串还原为加密时组装的二进制数据块 (`盐 + IV + 密文`)。

**2. 拆分加密组件**
根据加密时定义的固定长度和顺序，将解码后的二进制数据块精确地拆分成三个关键部分：
*   **前20字节**: 提取出加密时使用的**盐**。
*   **接下来的16字节**: 提取出**初始化向量 (IV)**。
*   **剩余部分**: 得到AES加密后的**核心数据密文**。

**3. 重新派生加密密钥**
为了成功解密数据，必须重新生成与加密时完全相同的密钥。
*   **获取主密码**: 程序会提示用户输入其导出文件时设置的主密码。
*   **执行PBKDF2**: 使用与加密时完全相同的参数——即用户输入的主密码、从文件中提取的20字节盐、HMAC-SHA-256伪随机函数以及70,000次迭代——来运行PBKDF2算法。
*   **验证与生成**: 此过程会计算出一个32字节的派生密钥。如果用户输入的密码正确，该密钥将与加密时使用的密钥完全一致；如果密码错误，生成的密钥将是错误的，导致后续解密失败。

**4. 解密与移除填充**
*   **执行AES解密**: 使用上一步重新派生的密钥和从文件中提取的IV，通过AES-256-CBC算法对密文进行解密。
*   **移除PKCS#7填充**: 解密成功后，程序会识别并安全地移除数据末尾的PKCS#7填充，从而得到纯净的、经过预处理的核心数据文本。

**5. 最终解析与数据还原**
此时得到的核心数据块仍然是经过编码和结构化的，需要进一步逆向解析才能还原为用户可读的信息。
*   **分割数据类型**: 首先，使用 `next_table` 关键字作为分隔符，将整个数据块分割成不同的部分（如密码、地址等）。
*   **记录与字段解析**: 在每个数据块内部，以换行符分割出单条记录，再以分号 (`;`) 作为分隔符切割出各个字段的Base64编码字符串。
*   **最终解码**: 对解析出的每一个字段，再次进行Base64解码（对应加密时的第一层编码），至此，才真正得到原始的、可读的明文信息（如用户名、密码、网址等）。
*   **数据清洗 (可选)**：最后，程序可能会对特定字段进行智能清洗，例如，将某些特定于安卓应用的网址链接（如 `androidapp://com.example.app`）转换为用户更易于理解和使用的标准网址。

---
### 致谢

本项目对三星密码本 (`.spass`) 文件的深度解析与解密功能的实现，完全建立在 **0xdeb7ef** 在其开源项目 [**spass-manager**](https://github.com/0xdeb7ef/spass-manager) 中卓越的逆向工程工作之上。我们的实现是对其核心逻辑的理解、重述和丰富。我们由衷感谢其为开源社区做出的宝贵贡献。